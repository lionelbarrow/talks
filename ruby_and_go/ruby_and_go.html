<!DOCTYPE html>
<!--[if lt IE 7]> <html class="no-js ie6" lang="en"> <![endif]-->
<!--[if IE 7]>    <html class="no-js ie7" lang="en"> <![endif]-->
<!--[if IE 8]>    <html class="no-js ie8" lang="en"> <![endif]-->
<!--[if gt IE 8]><!-->  <html class="no-js" lang="en"> <!--<![endif]-->
<head>
	<title>What Ruby developers can learn from Go</title>

	<meta name="description" content="What Ruby developers can learn from Go">
	<meta name="author" content="Lionel Barrow">
	<meta name="viewport" content="width=1024, user-scalable=no">

	<link rel="stylesheet" href="deckdotjs/core/deck.core.css">
	<link rel="stylesheet" href="deckdotjs/extensions/goto/deck.goto.css">
	<link rel="stylesheet" href="deckdotjs/extensions/menu/deck.menu.css">
	<link rel="stylesheet" href="deckdotjs/extensions/navigation/deck.navigation.css">
	<link rel="stylesheet" href="deckdotjs/extensions/status/deck.status.css">
	<link rel="stylesheet" href="deckdotjs/extensions/hash/deck.hash.css">

  <link rel="stylesheet" href="styles/default.css">
	<link rel="stylesheet" href="deckdotjs/themes/style/editorial.css">

	<script src="deckdotjs/modernizr.custom.js"></script>
</head>

<body class="deck-container">

<section class="slide">
<h1>What Ruby developers can learn from Go</h1>
</section>

<section class="slide">
<h1>Lionel Barrow @lionelbarrow</h1>
</section>

<section class="slide">
<h2>Why try new langages?</h2>
</section>

<section class="slide">
<h2>Why try new langages?</h2>
<ul>
  <li>PL communities have different practices, idioms, standards</li>
</ul>
</section>

<section class="slide">
<h2>Why try new langages?</h2>
<ul>
  <li>PL communities have different practices, idioms, standards</li>
  <li>Extremely idiosyncratic</li>
</ul>
</section>

<section class="slide">
<h2>Why try new langages?</h2>
<ul>
  <li>PL communities have different practices, idioms, standards</li>
  <li>Extremely idiosyncratic</li>
  <li>Difficult to judge practices until fairly deep into language</li>
</ul>
</section>

<section class="slide">
<h2>Why try new langages?</h2>
<ul>
  <li>PL communities have different practices, idioms, standards</li>
  <li>Extremely idiosyncratic</li>
  <li>Difficult to judge practices until fairly deep into language</li>
  <li>Vague notion that learning more languages will make us better developers. Can we be more concrete?</li>
</ul>
</section>

<section class="slide">
<h2>Getting concrete</h2>
</section>

<section class="slide">
<h2>Getting concrete</h2>
<ul>
  <li>You aren't better because you can now write +1 langauges</li>
</ul>

</section>
<section class="slide">
<h2>Getting concrete</h2>
<ul>
  <li>You aren't better because you can now write +1 langauges</li>
  <li>Exposure to more examples allows you to generalize your understanding of what you're doing</li>
</ul>
</section>

<section class="slide">
<h2>Getting concrete</h2>
<ul>
  <li>You aren't better because you can now write +1 langauges</li>
  <li>Exposure to more examples allows you to generalize your understanding of what you're doing</li>
  <li>Go back to old langauges and apply new paradigms, styles, idioms</li>
</ul>
</section>

<section class="slide">
<h2>Getting concrete</h2>
<ul>
  <li>You aren't better because you can now write +1 langauges</li>
  <li>Exposure to more examples allows you to generalize your understanding of what you're doing</li>
  <li>Go back to old langauges and apply new paradigms, styles, idioms</li>
  <li>Applies to all aspects of old languages: toolchain, source code organization, dependency management,
  testing style, deployment system, ... everything</li>
</ul>
</section>

<section class="slide">
<h2>Getting concrete</h2>
<ul>
  <li>You aren't better because you can now write +1 langauges</li>
  <li>Exposure to more examples allows you to generalize your understanding of what you're doing</li>
  <li>Go back to old langauges and apply new paradigms, styles, idioms</li>
  <li>Applies to all aspects of old languages: toolchain, source code organization, dependency management,
  testing style, deployment system, ... everything</li>
  <li>Understand idiomatic style of old language</li>
</ul>
</section>

<section class="slide">
<h2>What is idiomatic code?</h2>
</section>

<section class="slide">
<h2>What is idiomatic code?</h2>
<ul>
  <li>Simple definition: Idiomatic code uses language semantics and syntax to get greatest possible leverage on a problem</li>
</ul>
</section>

<section class="slide">
<h2>What is idiomatic code?</h2>
<ul>
  <li>Simple definition: Idiomatic code uses language semantics and syntax to get greatest possible leverage on a problem</li>
  <li>More important: idiomatic code is the community standard way or writing code; it <em>looks</em> familiar.</li>
</ul>
</section>

<section class="slide">
<h2>What is idiomatic code?</h2>
<ul>
  <li>Simple definition: Idiomatic code uses language semantics and syntax to get greatest possible leverage on a problem</li>
  <li>More important: idiomatic code is the community standard way or writing code; it <em>looks</em> familiar.</li>
  <li>Familiarity perhaps more important than anything else</li>
</ul>
</section>

<section class="slide">
<h2>Syntax and semantics influence idioms</h2>
</section>

<section class="slide">
<h2>Syntax and semantics influence idioms</h2>
<ul>
  <li>Goal of language designer: push programmers into writing good code naturally</li>
</ul>
</section>

<section class="slide">
<h2>Syntax and semantics influence idioms</h2>
<ul>
  <li>Goal of language designer: push programmers into writing good code naturally</li>
  <li>PLs influence programmers in subtle ways</li>
</ul>
</section>

<section class="slide">
<h2>Syntax and semantics influence idioms</h2>
<ul>
  <li>Goal of language designer: push programmers into writing good code naturally</li>
  <li>PLs influence programmers in subtle ways</li>
  <li>Simple example:

<pre><code class="ruby">it "is a testing example" do
end</pre></code>

  Instead of:

<pre><code class="ruby">it("is a testing example", do
end)</pre></code></li>
</ul>
</section>

<section class="slide">
<h2>Go</h2>
<ul>
  <li>Developed mostly at Google, but open source</li>
  <li>Compiled, garbage collected, strongly typed, object-oriented*</li>
  <li>Lower level language than Ruby, but still aimed at web</li>
</ul>
<p>Stuff we won't talk about today:</p>
<ul>
  <li>Metaprogramming ability limited compared to Ruby</li>
  <li>Concurrency constructs: goroutines, channels</li>
  <li>Toolchain: go fmt, go fix, GOPATH</li>
</ul>
</section>

<section class="slide">
<h2>Go style basics</h2>
<p>Overall question: what are the design goals here?</p>
</section>

<section class="slide">
<h2>Go style basics</h2>
<p>Overall question: what are the design goals here?</p>
<ul>
  <li>Declaration different from assignment</li>
</ul>
</section>

<section class="slide">
<pre><code class="golang">package main

func main() {
  a := 1
  a = 2

  b = 3 // Compiler error since b has not been declared

  var c int
  c = 4
}
</pre></code>
</section>

<section class="slide">
<h2>Go style basics</h2>
<p>Overall question: what are the design goals here?</p>
<ul>
  <li>Declaration different from assignment</li>
  <li>Exporting values from packages controlled by case</li>
</ul>
</section>

<section class="slide">
<pre><code class="go">package braintree

type CreditCard struct {
  Last4 string      // public
  number string     // not public
}

func ChargeCard(card CreditCard, amount int) {
  valid := validateCard(card)
  if valid { runTransaction(card, amount) }
}

func validateCard(card CreditCard) bool

func runTransaction(card CreditCard, amount int)
</pre></code>
</section>

<section class="slide">
<pre><code class="go">package main

import (
  "braintree"
  "fmt"
)

func main() {
  myCard := braintree.CreditCard{"5359", "314159265359"}
  braintree.ChargeCard(myCard, 100)
  fmt.Println("Charged card ending in %v", myCard.Last4)
}
</pre></code>
</section>

<section class="slide">
<h2>Go style basics</h2>
<p>Overall question: what are the design goals here?</p>
<ul>
  <li>Declaration different from assignment</li>
  <li>Exporting values from packages controlled by case</li>
  <li>Interface-oriented type system -- compile-time duck typing*</li>
</ul>
</section>

<section class="slide">
<pre><code class="go">package animals

type Animal interface { Eat(Animal) }

type Lion struct {}

func (this Lion) Eat(prey Animal) {} // Lion implements Animal

func (this Lion) Roar() {} // Lion has other methods

func Feed(hunter, prey Animal) {
  hunter.Eat(prey)
  hunter.Roar() // Compiler error because declared type was Animal
}
</code></pre>
</section>

<section class="slide">
<h2>Go style basics</h2>
<p>Overall question: what are the design goals here?</p>
<ul>
  <li>Declaration different from assignment</li>
  <li>Exporting values from packages controlled by case</li>
  <li>Interface-oriented type system -- compile-time duck typing*</li>
  <li>Functions often return multiple values; used for error handling</li>
</ul>
</section>

<section class="slide">
<pre><code class="go">package main

import (
  "errors"
  "fmt"
  "math/rand"
)

func complicatedOperation(input string) (string, error) {
  if rand.Rand() > 0.5 { return "Success!", nil }
  return "", errors.New("Not enough bananas")
}

func main() {
  output, err := complicatedOperation("input")
  if err != nil { fmt.Println("Error! " + err.Error()) }
  else { fmt.Println(output) }
}
</code></pre>
</section>

<section class="slide">
<h2>Where does this push us?</h2>
<ul>
  <li>Small, composable packages that do one thing well</li>
</ul>
</section>

<section class="slide">
<h2>Where does this push us?</h2>
<ul>
  <li>Small, composable packages that do one thing well</li>
  <li>Focus is on design of package API</li>
</ul>
</section>

<section class="slide">
<h2>Where does this push us?</h2>
<ul>
  <li>Small, composable packages that do one thing well</li>
  <li>Focus is on design of package API</li>
  <li>Error handling mostly done at level of package client</li>
</ul>
</section>

<section class="slide">
<h2>Where does this push us?</h2>
<ul>
  <li>Small, composable packages that do one thing well</li>
  <li>Focus is on design of package API</li>
  <li>Error handling mostly done at level of package client</li>
  <li>Where does business logic live?</li>
</ul>
</section>

<script src="deckdotjs/jquery-1.7.2.min.js"></script>
<script src="deckdotjs/core/deck.core.js"></script>
<script src="deckdotjs/extensions/hash/deck.hash.js"></script>
<script src="deckdotjs/extensions/menu/deck.menu.js"></script>
<script src="deckdotjs/extensions/goto/deck.goto.js"></script>
<script src="deckdotjs/extensions/status/deck.status.js"></script>
<script src="deckdotjs/extensions/navigation/deck.navigation.js"></script>

<script>
$(function() {
	$.deck('.slide');
});
</script>

<script src="highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
</body>
</html>
